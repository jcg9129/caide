#include "class_tester.h"
#include <stdexcept>

{{#solutionClass}}

namespace caide_tester {

{{#methods}}
void Method_{{method.name}}::call({{className}}*& solution) {
{{^method.type_is_void}}
    o_{{method.name}} =
{{/method.type_is_void}}
        solution->{{method.identifier.cpp}}(
{{#parameters}}
        i_{{name}}{{^islast}}, {{/islast}}
{{/parameters}}
    );
}
{{/methods}}

{{#constructor}}
void Method_{{className}}::call({{className}}*& solution) {
    solution = new {{className}}(
{{#parameters}}
        i_{{name}}{{^islast}}, {{/islast}}
{{/parameters}}
    );
}
{{/constructor}}

Test_{{className}}::Test_{{className}}() {
    {{#constructor}}solution = 0;{{/constructor}}
    {{^constructor}}solution = new {{className}}();{{/constructor}}
}

Test_{{className}}::~Test_{{className}}() {
    delete solution;
}

}

{{#isMultiMethodInput}}
void solve(std::istream& in, std::ostream& out) {
    caide_tester::Test_{{className}} tester;
    out << '[';
    bool first = true;
    std::string methodName;
    while (in >> methodName) {
        if (!first) {
            out << ", ";
            first = false;
        }
{{#constructor}}
        if (methodName == "{{className}}") {
            caide_tester::Method_{{className}}& m = tester.method_{{className}};
            m.readInputs(in);
            m.call(tester.solution);
            m.writeOutput(out);
        } else
{{/constructor}}
{{#methods}}
        if (methodName == "{{method.name}}") {
            caide_tester::Method_{{method.name}}& m = tester.method_{{method.name}};
            m.readInputs(in);
            m.call(tester.solution);
            m.writeOutput(out);
        } else
{{/methods}}
        {
            throw std::runtime_error(methodName + ": unknown method");
        }
    }

    out << ']';
}
{{/isMultiMethodInput}}
{{^isMultiMethodInput}}
void solve(std::istream& in, std::ostream& out) {
    caide_tester::Test_{{className}} tester;
{{#methods}}{{! Must be a single method }}
    caide_tester::Method_{{method.name}}& m = tester.method_{{method.name}};
    m.readInputs(in);
    m.call(tester.solution);
    m.writeOutput(out);
{{/methods}}
}
{{/isMultiMethodInput}}
{{/solutionClass}}
